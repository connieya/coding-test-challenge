# [N-Queen](https://school.programmers.co.kr/learn/courses/30/lessons/12952)

## 풀이

### 알고리즘

백트래킹 (Backtracking)

### 접근 방법

각 행에 하나씩 퀸을 배치하면서, 세로와 대각선 방향으로 공격 가능한 위치를 체크

3개의 boolean 배열을 사용하여 세로, 대각선(왼쪽 위→오른쪽 아래), 대각선(오른쪽 위→왼쪽 아래) 방향의 공격 가능 여부를 체크

### 풀이 과정:

1. **방문 체크 배열 초기화**

   - `v1[i]`: i번째 열(세로)에 퀸이 있는지 체크
   - `v2[L+i]`: 오른쪽 위에서 왼쪽 아래로 가는 대각선 체크 (행+열 인덱스)
   - `v3[L-i+n-1]`: 왼쪽 위에서 오른쪽 아래로 가는 대각선 체크 (행-열+n-1 인덱스)

### 인덱스 계산 원리 (자세한 설명):

#### 1. 세로 방향 (`v1[i]`)

- `i`번째 열에 퀸이 있으면 `v1[i] = true`
- 예: (0,2)에 퀸이 있으면 `v1[2] = true`

#### 2. 오른쪽 위 → 왼쪽 아래 대각선 (`v2[L+i]`)

- **같은 대각선에 있는 모든 칸은 `행+열` 값이 같습니다**
- 예시 (n=4 체스판, 괄호 안은 `행+열` 값):
  ```
    0    1    2    3
  0  0    1    2    3
  1  1    2    3    4
  2  2    3    4    5
  3  3    4    5    6
  ```
- 같은 대각선 예시:
  - (0,3), (1,2), (2,1), (3,0) → 모두 `행+열 = 3` → `v2[3]`으로 체크
  - (0,2), (1,1), (2,0) → 모두 `행+열 = 2` → `v2[2]`로 체크
  - (1,3), (2,2), (3,1) → 모두 `행+열 = 4` → `v2[4]`로 체크

#### 3. 왼쪽 위 → 오른쪽 아래 대각선 (`v3[L-i+n-1]`)

- **같은 대각선에 있는 모든 칸은 `행-열` 값이 같습니다**
- 하지만 `행-열`은 음수가 될 수 있으므로, `+n-1`을 더해서 인덱스를 0 이상으로 만듭니다
- 예시 (n=4, 괄호 안은 `행-열` 값):
  ```
    0     1     2     3
  0   0   -1   -2   -3
  1   1    0   -1   -2
  2   2    1    0   -1
  3   3    2    1    0
  ```
- `+n-1 = +3`을 하면 (괄호 안은 `행-열+3` 값):
  ```
    0    1    2    3
  0  3    2    1    0
  1  4    3    2    1
  2  5    4    3    2
  3  6    5    4    3
  ```
- 같은 대각선 예시:
  - (0,0), (1,1), (2,2), (3,3) → `행-열 = 0` → `+3` 후 모두 `3` → `v3[3]`으로 체크
  - (0,1), (1,2), (2,3) → `행-열 = -1` → `+3` 후 모두 `2` → `v3[2]`로 체크
  - (1,0), (2,1), (3,2) → `행-열 = 1` → `+3` 후 모두 `4` → `v3[4]`로 체크

**정리:**

- `v1[i]`: 세로(열) 방향 - i번째 열에 퀸이 있는지 체크
- `v2[L+i]`: 오른쪽 위→왼쪽 아래 대각선 - `행+열`이 같은 칸들을 하나의 인덱스로 매핑
- `v3[L-i+n-1]`: 왼쪽 위→오른쪽 아래 대각선 - `행-열`이 같은 칸들을 하나의 인덱스로 매핑 (음수 방지 위해 +n-1)

**예시 (n=4, 위치 (2,1)에 퀸 배치 시):**

- `v1[1] = true` (1번째 열 체크)
- `v2[2+1] = v2[3] = true` (행+열=3인 대각선 체크)
- `v3[2-1+4-1] = v3[4] = true` (행-열=1인 대각선 체크, +3 후 인덱스 4)

2. **DFS 탐색**

   - 각 행(L)에 대해 모든 열(i)을 시도
   - 현재 위치가 공격 가능한 위치인지 확인
     - 세로: `v1[i]`
     - 대각선1: `v2[L+i]`
     - 대각선2: `v3[L-i+n-1]`
   - 공격 가능한 위치가 아니면 퀸 배치 후 다음 행으로 재귀

3. **백트래킹**

   - 재귀 호출 후 방문 체크를 해제하여 다른 경우의 수 탐색

4. **결과 반환**
   - 모든 행에 퀸을 배치한 경우(L == n) 1을 반환
   - 모든 경우의 수를 합산하여 반환

### 시간 복잡도

O(n!) - 최악의 경우 n!개의 경우를 탐색하지만, 가지치기로 인해 실제로는 훨씬 적은 경우만 탐색

### 코드

```java
class Solution {
    boolean[] v1 = new boolean[13];  // 세로(열) 방향 체크
    boolean[] v2 = new boolean[30];  // 대각선 (오른쪽 위 → 왼쪽 아래, 행+열)
    boolean[] v3 = new boolean[30];  // 대각선 (왼쪽 위 → 오른쪽 아래, 행-열+n-1)

    public int dfs(int L, int n) {
        if (L == n) {
            return 1;
        }

        int cnt = 0;
        for (int i = 0; i < n; i++) {
            // 공격 가능한 위치인지 확인
            if (v1[i] || v2[L + i] || v3[L - i + n - 1]) {
                continue;
            }

            // 퀸 배치
            v1[i] = v2[L + i] = v3[L - i + n - 1] = true;
            cnt += dfs(L + 1, n);
            // 백트래킹: 퀸 제거
            v1[i] = v2[L + i] = v3[L - i + n - 1] = false;
        }

        return cnt;
    }

    public int solution(int n) {
        return dfs(0, n);
    }
}
```
